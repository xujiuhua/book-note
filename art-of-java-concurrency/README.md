# Java并发编程的艺术

## 并发编程的挑战

### 如何减少上下文切换
- 无锁并发编程：如将数据的id按照Hash算法取模分段，不同的线程处理不同段的数据
- CAS算法
- 使用最少线程
- 协程：在单线程里实现多任务的调度

### 避免死锁的常见方法
- 避免一个线程同时获得多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个所只占用一个资源
- 尝试使用定时锁，lock.tryLock(timeout)
- 对于数据库锁，加锁和解锁必须在一个数据库连接里

### 资源限制的挑战
例如服务器贷款2Mb/s,某个资源的下载速度是1Mb/s,系统启动10个线程，现在速度也不会达到10Mb/s
- 对于硬件资源限制，可以考虑使用集群并发执行程序；比如hadoop、ODPS
- 对于软件资源限制，可以考虑使用资源池将资源复用；比如数据库连接池，socket连接池等


## Java并发编程的底层实现原理
> Java中所使用的并发机制y依赖于JVM的实现和CPU的指令

### volatile 的两条实现原理
> 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1、L2或其他）后再进行操作，_但操作完，不知道何时会写入内存_。
如果对申明了volatile的变量进行写操作，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在内存行的数据写回到内存。但是就算写回到内存，其他处理器缓存的值还是旧的。
所以多处理器实现了缓存一致性，每个处理器会检查自己的缓存值是不是过期了，如发现地址被修改，则设置为无效状态，并重新从系统内存中把数据读到处理器缓存里

1. Lock前缀指令会引起处理器缓存回写到内存
2. 一个处理器的缓存回写内存，会导致其它处理的缓存无效

### 处理器如何实现原子操作
> Java中通过锁和循环CAS的方式来实现原子操作

1. 使用总线锁保证原子性
2. 使用缓存锁保证原子性

