# Java并发编程的艺术

## 并发编程的挑战

### 如何减少上下文切换
- 无锁并发编程：如将数据的id按照Hash算法取模分段，不同的线程处理不同段的数据
- CAS算法
- 使用最少线程
- 协程：在单线程里实现多任务的调度

### 避免死锁的常见方法
- 避免一个线程同时获得多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个所只占用一个资源
- 尝试使用定时锁，lock.tryLock(timeout)
- 对于数据库锁，加锁和解锁必须在一个数据库连接里

### 资源限制的挑战
例如服务器贷款2Mb/s,某个资源的下载速度是1Mb/s,系统启动10个线程，现在速度也不会达到10Mb/s
- 对于硬件资源限制，可以考虑使用集群并发执行程序；比如hadoop、ODPS
- 对于软件资源限制，可以考虑使用资源池将资源复用；比如数据库连接池，socket连接池等


## Java并发编程的底层实现原理
> Java中所使用的并发机制y依赖于JVM的实现和CPU的指令

### volatile 的两条实现原理
> 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1、L2或其他）后再进行操作，_但操作完，不知道何时会写入内存_。
如果对申明了volatile的变量进行写操作，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在内存行的数据写回到内存。但是就算写回到内存，其他处理器缓存的值还是旧的。
所以多处理器实现了缓存一致性，每个处理器会检查自己的缓存值是不是过期了，如发现地址被修改，则设置为无效状态，并重新从系统内存中把数据读到处理器缓存里

1. Lock前缀指令会引起处理器缓存回写到内存
2. 一个处理器的缓存回写内存，会导致其它处理的缓存无效

### 处理器如何实现原子操作
> Java中通过锁和循环CAS的方式来实现原子操作

1. 使用总线锁保证原子性
2. 使用缓存锁保证原子性

## Java内存模型

### happens-before
两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！
happens-before仅仅要求前一个操作对（执行的结果）后一个操作可见

1. 程序顺序规则
2. 监视器锁规则：对一个锁的解锁, happens-before于随后这个锁的加锁
3. volatile规则: 对一个volatile域的写，happens-before 任意后续对这个volatile域的读
4. 传递性：A happens-before B ,B happens-before C --> A happens-before C

### 重排序-三种数据依赖性
- 写后读: a = 1; b = a;
- 写后写: a = 1; a = 2;
- 读后写: a = b; b = 1;

只要重排序两个操作的执行顺序，程序的执行结果就会被改变

在单线程中，对存在控制依赖的操作重排序，不会改变执行结果（as-if-serial语义允许）；
在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

### 双重检验锁定和延迟初始化
见`DoubleCheckedLocking`
问题根源在第7行`instance = new Instance();`，可以分解为如下：
```
memory = allocate();
ctorInstance(memory);
instance = memory;
```
然后重排序为,单线程不会改变程序的执行结果，以下重排序允许，例如第4步调用instance,无论如何2肯定是在4前面，合理；
但是线程会导致从步骤3多读取到一个不完整的对象。
```
memory = allocate(); // 1分配内存空间
instance = memory; // 3指向内存地址
ctorInstance(memory); // 2初始化对象
```

解决办法：1、使用volatile 2、基于类的初始化

## Java并发编程基础
### Java线程状态
> ThreadState.java, 使用java自带工具查看， jps, jstack pid
- NEW: 初始状态，但是还乜有调用start()方法
- RUNNABLE: 运行状态
- BLOCKED: 阻塞状态,表示线程阻塞于锁
- WAITING: 等待状态，需要其他线程做出动作（通知或中断）e.g.  Waiting.class.wait()
- TIME_WAITING: 超时等待，可以在指定时间自行返回，e.g. Thread.sleep(100)
- TERMINATED: 终止状态，线程已执行完毕

### 安全地终止线程
> Shutdown.java

通过标识位或者中断操作的方式，能够使线程在终止时有机会去清理资源，而不是武断的将线程停止

### 等待通知机制
> WaitNotify.java
- notify() 通知一个在对象上等待的线程，使其从wait方法返回，而返回的前提是该线程获取到了对象的锁
- notifyAll() 通知所有等待在该对象上的线程
- wait() 调用该方法线程进入WAITING状态，只有等待另外线程的通知或中断才会返回，注意调用此方法，会释放对象锁
- wait(long) 超时等待
- wait(long, int) 超时等待，时间更细粒

## Java中的锁

独占锁：在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放锁，后继的线程才能获取锁

## Java中的并发工具类
- CountDownLatch 允许一个或者多个线程等待其他线程完成工作
- CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier